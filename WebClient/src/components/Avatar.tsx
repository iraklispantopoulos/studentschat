/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/avatar.glb -o src/components/Avatar.tsx -r public --typescript 
*/
import React, { useImperativeHandle, forwardRef, useState, useEffect, useRef,Ref } from 'react';
import { useGraph,useFrame } from '@react-three/fiber'
import { useGLTF, useFBX, useAnimations } from '@react-three/drei'
import { SkeletonUtils, GLTF } from 'three-stdlib'
import * as THREE from 'three';
import { Speech } from '../models/Shared';
import { AvatarGenderTypeEnum } from '../api/GeneratedApiClient';
const corresponding: Record<"A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "X", string> = {
	A: "viseme_PP",
	B: "viseme_kk",
	C: "viseme_I",
	D: "viseme_aa",
	E: "viseme_O",
	F: "viseme_U",
	G: "viseme_FF",
	H: "viseme_TH",
	X: "viseme_PP",
};

type GLTFResult = GLTF & {
	nodes: {
		Wolf3D_Hair: THREE.SkinnedMesh
		Wolf3D_Outfit_Top: THREE.SkinnedMesh
		Wolf3D_Outfit_Bottom: THREE.SkinnedMesh
		Wolf3D_Outfit_Footwear: THREE.SkinnedMesh
		Wolf3D_Body: THREE.SkinnedMesh
		EyeLeft: THREE.SkinnedMesh
		EyeRight: THREE.SkinnedMesh
		Wolf3D_Head: THREE.SkinnedMesh
		Wolf3D_Teeth: THREE.SkinnedMesh
		Hips: THREE.Bone
	}
	materials: {
		Wolf3D_Hair: THREE.MeshStandardMaterial
		Wolf3D_Outfit_Top: THREE.MeshStandardMaterial
		Wolf3D_Outfit_Bottom: THREE.MeshStandardMaterial
		Wolf3D_Outfit_Footwear: THREE.MeshStandardMaterial
		Wolf3D_Body: THREE.MeshStandardMaterial
		Wolf3D_Eye: THREE.MeshStandardMaterial
		Wolf3D_Skin: THREE.MeshStandardMaterial
		Wolf3D_Teeth: THREE.MeshStandardMaterial
	}
	animations: GLTFAction[]
}
interface AvatarProps {
	groupProps: JSX.IntrinsicElements['group'];
	speech?: Speech;
	gender: AvatarGenderTypeEnum;
}

// Interface for the metadata section
interface Metadata {
	soundFile: string; // Path to the sound file
	duration: number;  // Duration of the sound file
}

// Interface for each mouth cue
interface MouthCue {
	start: number; // Start time of the cue
	end: number;   // End time of the cue
	value: "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "X"; // Value of the mouth shape
}

// Root interface for the entire JSON structure
interface LipSyncData {
	metadata: Metadata;      // Metadata about the audio file
	mouthCues: MouthCue[];   // Array of mouth cues
}
export interface AvatarRef {
	repeatSpeech: () => void;
}

function Avatar({ groupProps, speech, gender }: AvatarProps, ref:Ref<AvatarRef>) {
	speech = speech || { audioUrl: '', mouthCuesUrl: '', speechFileName: '' };
	gender = gender || AvatarGenderTypeEnum.Male;
	var model = "avatar";
	if (gender == AvatarGenderTypeEnum.Female)
		model = "avatar-female";
	const [responseHistory, setResponseHistory] = useState<string[]>([]);
	const { animations: idleAnimation } = useFBX('/animations/Idle.fbx')
	const { animations: greetingAnimation } = useFBX('/animations/Standing Greeting.fbx')	
	const [audio, setAudio] = useState<HTMLAudioElement | null>(null);
	const [lipsync, setLipsync] = useState<LipSyncData | null>(null);
	const { scene } = useGLTF(`/models/${model}.glb`)
	const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
	const { nodes, materials } = useGraph(clone) as GLTFResult

	idleAnimation[0].name = 'Idle'
	greetingAnimation[0].name = 'Greeting'

	const repeatSpeech = () => {
		talk();
	};
	const group = useRef<THREE.Group | null>(null);
	const { actions } = useAnimations(
		[idleAnimation[0],
		greetingAnimation[0]],
		group
	);
	useEffect(() => {
		console.log(nodes.Wolf3D_Head.morphTargetDictionary);
		nodes.Wolf3D_Head.morphTargetInfluences![nodes.Wolf3D_Head.morphTargetDictionary!["viseme_PP"]] = 1;
		nodes.Wolf3D_Teeth.morphTargetInfluences![nodes.Wolf3D_Teeth.morphTargetDictionary!["viseme_PP"]] = 1;
		nodes.Wolf3D_Head.morphTargetInfluences![nodes.Wolf3D_Head.morphTargetDictionary!["smile"]] = 1;
	}, []);		

	useEffect(() => {
		if (actions && actions.Idle) {
			actions.Idle.play(); // Remove reset and fadeIn to avoid unnecessary interruptions
		}
	}, [actions]);

	useEffect(() => {

		if (speech.audioUrl === '' || speech.mouthCuesUrl === '' || responseHistory.includes(speech.speechFileName)) return;
		talk();
	}, [speech.audioUrl, speech.mouthCuesUrl]);
	const talk = () => {
		try {
			const loadJson = async () => {
				try {
					const response = await fetch(speech.mouthCuesUrl);
					if (!response.ok) {
						throw new Error(`Failed to fetch JSON: ${response.statusText}`);
					}
					const parsedLipsync = await response.json();
					if (lipsync !== parsedLipsync) {
						setLipsync(parsedLipsync);
					}

					const newAudio = new Audio(speech.audioUrl);
					//if (audio == null || audio?.src !== newAudio.src) {
						setAudio(newAudio);
						newAudio?.play();
						setResponseHistory(prevHistory => [...prevHistory, speech.speechFileName]);
					//}
				} catch (error) {
					console.error("Error loading JSON file:", error);
				}
			};

			(async () => {
				await loadJson();
			})();
		} catch (err) {
			console.log(err);
		}
	}
	useFrame((state) => {
		if (group?.current)
			(group.current as any).getObjectByName("Head")?.lookAt(state.camera.position);
		if (!audio?.paused && lipsync) {
			Object.values(corresponding).forEach((value) => {
				nodes.Wolf3D_Head.morphTargetInfluences![nodes.Wolf3D_Head.morphTargetDictionary![value]] = 0;
				nodes.Wolf3D_Teeth.morphTargetInfluences![nodes.Wolf3D_Teeth.morphTargetDictionary![value]] = 0;
			});
			const currentAudioTime = audio!.currentTime;
			for (let i = 0; i < lipsync!.mouthCues!.length; i++) {
				const mouthCue = lipsync!.mouthCues[i]!;
				if (currentAudioTime >= mouthCue.start && currentAudioTime <= mouthCue.end) {
					//console.log(mouthCue.value);
					nodes.Wolf3D_Head.morphTargetInfluences![nodes.Wolf3D_Head.morphTargetDictionary![corresponding[mouthCue.value]]] = 1;
					nodes.Wolf3D_Teeth.morphTargetInfluences![nodes.Wolf3D_Teeth.morphTargetDictionary![corresponding[mouthCue.value]]] = 1;
					//console.log("current audio time:" + currentAudioTime);
					//console.log(nodes.Wolf3D_Head.morphTargetDictionary![corresponding[mouthCue.value]]);
					//console.log(nodes.Wolf3D_Teeth.morphTargetDictionary![corresponding[mouthCue.value]]);
					break;
				}
			}
		}
	});
	if (ref) {
		useImperativeHandle(ref, () => ({
			repeatSpeech,
		}));
	}
	return (
		<group {...groupProps} dispose={null} ref={group}>
			<primitive object={nodes.Hips} />
			<skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
			<skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
			<skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
			<skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
			<skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
			<skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
			<skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
			<skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} />
			<skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
		</group>
	)
}
export default forwardRef(Avatar);
useGLTF.preload('/models/avatar.glb')

